---
title: "Kubernetes Workloads에 대하여"
date: 2023-11-06T22:15:17+09:00
tags:
  - kubernetes
  - container
categories:
  - kubernetes
published: false
---

# Workloads

- Deployment & ReplicaSet: 필요할 때마다 파드를 교체할 수 있는 무상태(stateless) 애플리케이션에 적합
- StatefulSet: 데이터를 지속적으로 유지하는 등의 상태를 추적하는 하나 이상의 관련 파드를 실행하는 데 사용
- DaemonSet: 각 노드에서 실행되어야 하는 파드를 보장하여 일반적으로 노드 수준의 작업에 사용
- Job & CronJob: 완료되면 중단되는 작업을 정의. 잡은 한 번 실행되고, 크론잡은 정해진 일정에 따라 주기적으로 실행된다.

## Pods

파드는 쿠버네티스에서 생성하고 관리할 수 있는 가장 작은 배포 가능한 컴퓨팅 단위이다. 파드는 공유 스토리지 및 네트워크 자원을 가진 하나 이상의 컨테이너 그룹으로, 컨테이너를 실행하는 방법에 대한 명세를 포함한다.  
파드의 내용은 항상 공동 위치에 있으며 공동으로 스케줄링되고 **공유 컨텍스트**에서 실행된다. 파드는 애플리케이션 특정 "논리 호스트"를 모델링하며, 상대적으로 긴밀하게 연결된 하나 이상의 애플리케이션 컨테이너를 포함한다.

파드의 **공유 컨텍스트**는 linux namespace, cgroups 및 격리의 기능들로 구성되며, 이는 컨테이너를 격리하는 것과 동일한 것들이다. 파드의 컨텍스트 내에서 개별 애플리케이션은 추가적인 하위 격리를 적용받을 수 있다.

파드는 단일 컨테이너를 실행하는 경우와 여러 컨테이너가 함께 작동해야 하는 경우 두 가지 주요 방식으로 사용된다.

- "**한 파드 당 하나의 컨테이너**" 모델은 가장 일반적인 쿠버네티스 사용 사례로, 이 경우 파드를 단일 컨테이너를 둘러싼 래퍼로 생각할 수 있으며, 쿠버네티스는 컨테이너가 아닌 파드를 관리한다.
- 파드는 공유 자원을 필요로 하는 긴밀하게 연결된 여러 컨테이너로 구성된 애플리케이션을 **캡슐화**할 수 있다.

**컨트롤러**

파드는 일반적으로 직접 생성되지 않으며, 대신 Deployment나 Job과 같은 워크로드 리소스를 사용하여 생성된다. 컨트롤러는 복제 및 롤아웃을 관리하고 파드 실패 시 자동 복구를 담당한다.  
예를 들어, 노드가 실패하면 컨트롤러는 해당 노드에서 작동을 멈춘 파드를 감지하고 대체 파드를 생성한다. 스케줄러는 대체 파드를 건강한 노드에 배치한다.

**네트워크와 스토리지**

파드는 이러한 컨테이너, 저장소 자원 및 일시적인 네트워크 신원을 단일 단위로 묶는다. 각 파드는 주어진 애플리케이션의 단일 인스턴스를 실행하도록 설계되었다. 애플리케이션을 수평으로 확장하려면 여러 Pod를 사용해야 한다.  
쿠버네티스에서 이는 일반적으로 복제라고 한다. 복제된 파드는 일반적으로 워크로드 리소스와 해당 컨트롤러에 의해 그룹으로 생성 및 관리된다.

파드는 **네트워크**와 **저장소**라는 두 가지 유형의 공유 리소스를 기본적으로 제공한다. 파드를 직접 생성하는 것은 드물며, 싱글톤 파드조차도 대부분 워크로드 리소스를 사용하여 생성된다. 직접 또는 컨트롤러에 의해 Pod가 생성되면, 새로운 Pod는 클러스터의 노드 중 하나에서 실행되도록 예약된다.  
파드는 실행이 완료될 때까지, 파드 객체가 삭제될 때까지, 리소스 부족으로 인해 파드가 추방될 때까지, 또는 노드가 실패할 때까지 해당 노드에 남아 있는다.

**이름에 관한 주의사항**

파드의 이름은 유효한 DNS 하위 도메인 값이어야 한다. 하지만 이는 Pod 호스트 이름에 대해 예상치 못한 결과를 초래할 수 있다. 최상의 호환성을 위해, 이름은 DNS 레이블에 대한 더 엄격한 규칙을 따르는 것이 좋다.

### Pod Lifecycle

파드는 상태를 포함한 정의된 라이프사이클을 다음과 같이 가지고 있다. 

- `Pending`: 파드가 쿠버네티스 시스템에 의해 만들어졌으나, 하나 이상의 컨테이너가 설저오디고 실행 준비를 마치지 못하였다. 이 시간에는 스케줄링 전 시간과 네트워크를 통한 이미지 다운로드 시간을 포함한다.
- `Running`: 파드가 노드에 바인딩되었고 모든 컨테이너가 생성되었다. 적어도 하나의 컨테이너가 여전히 실행 중이거나 시작 또는 재시작 과정에 있다.
- `Succeeded`: 파드의 모든 컨테이너가 성공적으로 종료되었으며, 다시 시작되지 않는다.
- `Failed`: 파드의 모든 컨테이너가 종료되었고 적어도 하나의 컨테이너가 실패로 종료되었다. 즉, 컨테이너가 0이 아닌 상태로 종료되었거나 시스템에 의해 종료되었다.
- `Unknown`: 어떤 이유로 파드의 상태를 얻을 수 없다. 일반적으로 파드와 호스트의 통신 오류인 경우가 많다.

### Pod Lifecycle Event

- `Scheduled`: 파드가 노드에 할당됨
- `Pulling`: 쿠버네티스가 컨테이너의 이미지를 가져오고 있음
- `Pulled`: 이미지가 성공적으로 가져옴
- `Created`: 쿠버네티스가 컨테이너를 생성함
- `Started`: 쿠버네티스가 컨테이너를 시작함
- `Killing`: 쿠버네티스가 컨테이너를 종료하고 있음
- `Killed`: 컨테이너가 종료됨

### Pod Condition

파드는 파드가 통과했거나 통과하지 못한 파드의 조건을 가진 PodStatus를 가지고 있다.

- `PodScheduled`: 파드가 노드에 스케줄됨
- `ContainersReady`: 파드의 모든 컨테이너가 준비됨
- `Initialized`: 모든 초기화 컨테이너가 성공적으로 시작됨
- `Ready`: 파드가 요청을 처리할 수 있으며 모든 일치하는 서비스의 로드 밸런싱 풀에 추가되어야 한다.

### Container Probe

프로브란 쿠버네티스에 의해 주기적으로 컨테이너에서 수행되는 진단으로, 이를 수행하기 위해 쿠버네티스는 컨테이너에 구현된 3가지 핸들러를 호출한다.

- `ExecAction`: 컨테이너 내부에서 지정된 명령을 실행한다. 명령이 상태 코드 0으로 종료되면 진단이 성공한 것으로 간주된다
- `TCPSocketAction`: 지정된 포트에서 컨테이너의 IP 주소에 대해 TCP 검사를 수행한다. 포트가 열려 있으면 진단이 성공한 것으로 간주된다.
- `HTTPGetAction`: 지정된 포트와 경로에서 컨테이너의 IP 주소에 대해 HTTP Get 요청을 수행한다. 응답이 상태 코드가 200 이상 400 미만이면 진단이 성공한 것으로 간주된다.

### Init Container

파드는 애플리케이션 컨테이너가 시작하기 전에 실행되는 초기화 컨테이너를 가질 수 있다. 이러한 컨테이너는 앱 이미지에 없는 유틸리티나 설정 스크립트를 포함하기 위한 것이다.  
초기화 컨테이너는 애플리케이션 컨테이너가 시작하기 전에 완료될 수 있으며, 파드가 정상적으로 작동하려면 초기화 컨테이너는 무조건 성공해야 한다.

- 초기화 컨테이너는 애플리케이션 컨테이너와 동일한 이미지를 사용하거나, 애플리케이션 컨테이너와는 다른 이미지를 사용할 수 있다.
- 각 초기화 컨테이너는 앞선 컨테이너가 성공적으로 완료될 때까지 순차적으로 실행된다.
- 모든 초기화 컨테이너가 성공적으로 실행되면, 쿠버네티스는 팟의 애플리케이션 컨테이너를 순차적으로 시작한다.
- 초기화 컨테이너가 실패할 경우, 쿠버네티스는 실패한 컨테이너를 재시도한다.
- 초기화 컨테이너는 애플리케이션 컨테이너가 시작되기 전에 필요한 설정 작업이나 종속성을 준비하는 데 유용하다.
- 초기화 컨테이너는 애플리케이션 컨테이너와 파일 시스템을 공유할 수 있으므로, 애플리케이션 컨테이너가 사용할 데이터를 준비하거나 구성할 수 있다.

특히, 애플리케이션 컨테이너와 **라이프사이클 훅**과 **리소스 요청 및 제한**은 공유하지 않는다. 

### Pod Lifetime

일반적으로 파드는 운영자나 컨트롤러가 파괴할 때까지 사라지지 않는다. 이 규칙의 유일한 예외는 `Succeeded` 또는 `Failed` 단계의 파드가 일정 기간(`terminatedPodGCThreshold`) 이상 지속되면 만료되어 자동으로 파괴된다.

### Pod Presets

파드 프리셋은 생성 시 파드에 추가적인 런타임 요구 사항을 주입하는 데 사용할 수 있는 API 리소스이다. 주어진 파드 프리셋이 적용되는 파드를 지정하기 위해 레이블 선택자를 사용한다

### Pod Overhead

쿠버네티스에서는 사이드카 컨테이너를 실행하는 데 관련된 오버헤드를 기반으로 파드 수준에서 파드의 오버헤드가 설정된다. 이 오버헤드는 컨테이너의 리소스 요청 및 제한에 추가하여 계산된다.

## Disruptions

중단에 대해서 이야기하기 전에 중단의 종류에 대해서 알아야한다. 자발적 중단(**Voluntary disruptions**)과 비자발적 중단(**Involuntary disruptions**) 두 가지의 종류의 중단이 존재한다.  
예시를 통해서 더 알아보도록 하자.

비자발적 중단 (**Involuntary disruptions**)
- 노드를 백업하는 물리적 기계의 실패
- 관리자가 실수로 VM 삭제
- 클라우드 프로바이더나 하이퍼바이저 오류로 인해 VM 삭제
- 커널 패닉
- 클러스터 네트워크 파티션으로 인한 노드 삭제
- 노드 자원 부족으로 인한 파드 추방

자발적 중단 (**Voluntary disruptions**)
- 파드 관리하는 워크로드나 컨트롤러 삭제
- 파드 템플릿의 업데이트로 인한 재시작
- 의도적인 파드 삭제
- 업데이트나 디버깅을 위한 노드 드레인
- 클러스터 오토스케일링

이렇듯 자발적 중단이 자주 발생하면 고가용성 애플레케이션을 운영하는데에 지장이 생긴다. 이러한 상황에도 적어도 어느 정도의 서비스를 유지하고 싶다는 니즈를 충족시키기 위한 기능을 `PodDisruptionBudget` (PDB)라고 한다.  
PDB는 자발적 중단으로 인해 동시에 다운되는 애플리케이션의 파드 수를 제한할 수 있다. 만약, 최소한의 파드 개수를 보장해야하는 경우 (쿼럼 기반, 클러스터 기반) PDB를 사용하면 최소한의 파드를 보장 받을 수 있다.  

애플리케이션마다 PDB를 설정할 수 있으며, 자발적 중단 (node drain)과 같은 상황이 발생하였을 때 deployment의 `.spec.replicas`만큼 유지하다가 PDB의 `minAvailable`만큼만 제외하고 드레인이 진행된다.

### Pod disruption conditions v1.26 [beta]

- `PreemptionByScheduler`: 스케줄러에 의해 우선 순위가 더 높은 새로운 파드를 수용하기 위해 선점 될 예정
- `DeletionByTaintManager`: 파드가 Taint Manager에 의해 삭제될 예정
- `EvictionByEvictionAPI`: 쿠버네티스 Eviction API에 evict 예정
- `DeletionByPodGC`: 더 이상 존재하지 않은 노드에 바인딩 된 파드가 가비지 컬렉터에 의해 삭제될 예정
- `TerminationByKubelet`: 파드는 evict 혹은 노드의 graceful shutdown으로 kubelet에 의해 종료됨

Job이나 CronJob에서도 사용할 수 있으며, 파드 실패 정책으로 이용 될 수 있다.

---